# HJ24 合唱队
中等  通过率：26.54%  时间限制：1秒  空间限制：32M

# 知识点
- 动态规划
- 队列

# 描述
N 位同学站成一排，音乐老师要请最少的同学出列，使得剩下的K位同学排成合唱队形。

设K位同学从左到右依次编号为1，2…，K ，他们的身高分别为$T_1$,$T_2$,…,$T_K$ ，若存在$i(1\leq i\leq K)$ 使得$T_1<T_2<......<T_{i-1}<T_i$
且$T_i>T_{i+1}>......>T_K$，则称这K名同学排成了合唱队形。

通俗来说，能找到一个同学，他的两边的同学身高都依次严格降低的队形就是合唱队形。
## 例子： 
123 124 125 123 121 是一个合唱队形
123 123 124 122不是合唱队形，因为前两名同学身高相等，不符合要求
123 122 121 122不是合唱队形，因为找不到一个同学，他的两侧同学身高递减。

## 任务
你的任务是，已知所有$N$位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

注意：不允许改变队列元素的先后顺序 且不要求最高同学左右人数必须相等

## 数据范围： $1 \le n \le 3000$ 

## 输入描述：
用例两行数据，第一行是同学的总数 N ，第二行是 N 位同学的身高，以空格隔开

## 输出描述：
最少需要几位同学出列

# 示例1
## 输入：
8
186 186 150 200 160 130 197 200
## 输出：
4
## 说明：
由于不允许改变队列元素的先后顺序，所以最终剩下的队列应该为186 200 160 130或150 200 160 130        

# 解答
## 分析
将编号[1,K]映射为数组序号[0,K-1]
- 分别以序号为[1,k-2]的同学作为身高最高的同学形成合唱队，求需出列同学的最小值
- 序号为i的同学作为身高最高的同学形成合唱队需出列同学的值的求法
  - 求出以序号为i的同学身高为末尾元素的递增序列长度left
  - 求出以编号为i的同学身高为起始元素的递减序列长度right
  - 合唱队中需出列同学值为K-left-right+1

## 解答一
- 用数组lis存储以序号$i \in [0，K-1]$为末尾元素的最长递增子序列的长度
  - 从序号0开始，依次填写lis
  $$
    lis[j] = 
    \begin{cases}
        max \{lis[t]|t < j,heights[t] < heights[j]\}+1, & j > 0\\
        1, & j = 0
    \end{cases}
  $$
- 用数组lds存储以序号$i \in [0，K-1]$为首元素的最长递减子序列的长度
  $$
    lds[j] = 
    \begin{cases}
        max \{lds[t]|t < j,heights[t] < heights[j]\}+1, & j > 0\\
        1, & j = 0
    \end{cases}
  $$
- $i \in [1,K-2]$时序号为i的同学作为身高最高的同学形成合唱队需出列同学的值为$K-left[i]-right[i]+1$，选出最小值即可

## 解答二
- 解答一中，遍历计算lis和lds列表需O(N)时间，计算每个lis[k]或lds[k]需O(N)时间。
- 计算单个lis[k]和lds[k]可使用二分查找进行改进，可将此部分复杂度降至O(logn)，总复杂度降至O(nlogn)
- 计算lis或lds时，可维护一个列表tails，其中每个元素tails[k]的值代表长度为k+1的子序列端部元素的最小值。
- 在遍历计算每个tails[k]，不断更新长度为[1,k]的子序列尾部元素值，始终保持每个尾部元素值最小 （例如 [1,5,3]， 遍历到元素 5 时，长度为 2 的子序列尾部元素值为 5；当遍历到元素 3 时，尾部元素值应更新至 3，因为 3 遇到比它大的数字的几率更大）。
- 设 res为 tails 当前长度，代表直到当前的最长上升子序列长度。设$j \in [0,res)$，考虑每轮遍历 nums[k] 时，通过二分法遍历 [0,res) 列表区间，找出 nums[k] 的大小分界点，会出现两种情况：
  - 区间中存在 tails[i] > nums[k]： 对于第一个满足 tails[i] > nums[k]的tails[k]值 执行 tails[i] = nums[k]；因为更小的 nums[k] 后更可能接一个比它大的数字。
  - 区间中不存在 tails[i] > nums[k]： 意味着 nums[k]可以接在前面所有长度的子序列之后，因此肯定是接到最长的后面（长度为 res ），新子序列长度为 res + 1。
